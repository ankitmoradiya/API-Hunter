// apihunter/internal/export/openapi.go
package export

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/apihunter/apihunter/internal/analyzer"
	"github.com/apihunter/apihunter/internal/models"
	"gopkg.in/yaml.v3"
)

// OpenAPIExporter generates OpenAPI 3.0 specification
type OpenAPIExporter struct{}

// NewOpenAPIExporter creates a new OpenAPI exporter
func NewOpenAPIExporter() *OpenAPIExporter {
	return &OpenAPIExporter{}
}

type openAPISpec struct {
	OpenAPI string              `yaml:"openapi"`
	Info    openAPIInfo         `yaml:"info"`
	Servers []openAPIServer     `yaml:"servers"`
	Paths   map[string]pathItem `yaml:"paths"`
}

type openAPIInfo struct {
	Title       string `yaml:"title"`
	Description string `yaml:"description"`
	Version     string `yaml:"version"`
}

type openAPIServer struct {
	URL string `yaml:"url"`
}

type pathItem map[string]operation

type operation struct {
	Tags       []string    `yaml:"tags,omitempty"`
	Summary    string      `yaml:"summary"`
	Parameters []parameter `yaml:"parameters,omitempty"`
	Responses  responses   `yaml:"responses"`
}

type parameter struct {
	Name     string       `yaml:"name"`
	In       string       `yaml:"in"`
	Required bool         `yaml:"required"`
	Schema   schemaObject `yaml:"schema"`
}

type schemaObject struct {
	Type string `yaml:"type"`
}

type responses map[string]responseObject

type responseObject struct {
	Description string `yaml:"description"`
}

// Export generates OpenAPI YAML file
func (e *OpenAPIExporter) Export(result *models.ScanResult, groups []analyzer.EndpointGroup, outputDir string) error {
	spec := openAPISpec{
		OpenAPI: "3.0.3",
		Info: openAPIInfo{
			Title:       fmt.Sprintf("%s - Discovered API", result.Target),
			Description: "Auto-generated by APIHunter",
			Version:     fmt.Sprintf("discovered-%s", time.Now().Format("2006-01-02")),
		},
		Servers: []openAPIServer{{URL: result.Target}},
		Paths:   make(map[string]pathItem),
	}

	for _, group := range groups {
		for _, ep := range group.Endpoints {
			path := ep.NormalizedPath
			if path == "" {
				path = ep.Path
			}
			if path == "" {
				continue
			}

			if _, exists := spec.Paths[path]; !exists {
				spec.Paths[path] = make(pathItem)
			}

			for _, method := range ep.Methods {
				methodLower := strings.ToLower(method)
				tags := append([]string{group.Name}, ep.Tags...)

				op := operation{
					Tags:      tags,
					Summary:   fmt.Sprintf("%s %s (inferred)", method, path),
					Responses: responses{"200": {Description: "Success"}},
				}

				// Add path parameters
				for _, p := range ep.Parameters {
					op.Parameters = append(op.Parameters, parameter{
						Name:     p.Name,
						In:       p.In,
						Required: p.Required,
						Schema:   schemaObject{Type: p.Type},
					})
				}

				// Add query parameters
				for _, p := range ep.QueryParams {
					op.Parameters = append(op.Parameters, parameter{
						Name:     p.Name,
						In:       "query",
						Required: false,
						Schema:   schemaObject{Type: "string"},
					})
				}

				spec.Paths[path][methodLower] = op
			}
		}
	}

	// Write to file
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return err
	}

	data, err := yaml.Marshal(spec)
	if err != nil {
		return err
	}

	return os.WriteFile(filepath.Join(outputDir, "openapi.yaml"), data, 0644)
}
